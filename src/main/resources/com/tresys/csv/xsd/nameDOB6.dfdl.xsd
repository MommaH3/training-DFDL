<?xml version="1.0" encoding="UTF-8"?> 
<!-- Copyright (c) 2019 Tresys Technology, LLC. All rights reserved. -->

<xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/" 
  xmlns:tns="http://example.com"
  xmlns:ex="http://example.com"
  targetNamespace="http://example.com">

  <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd" />

  <xs:annotation>
    <xs:appinfo source="http://www.ogf.org/dfdl/">

      <dfdl:format ref="tns:GeneralFormat"
                   representation="binary"
                   byteOrder="bigEndian"
                   bitOrder="mostSignificantBitFirst"
                   encoding="ASCII"
                   lengthUnits='bits'
                   alignment="1"
                   alignmentUnits="bits"
                   occursCountKind="expression"
                   binaryNumberRep="binary"/>

    </xs:appinfo>
  </xs:annotation>

  <!-- Presence Indicators or PIs -->

  <!--
  EXERCISE

  Define a reusable simple type named "PI"
  which is an unsignedByte, with explicit lengthKind
  and length 1 bit.
  -->
  <xs:simpleType name="PI"
                 ... properties here ...
                 >
    <!-- This is how you derive a new simple type from an existing one. -->
    <xs:restriction base="xs:unsignedByte"/>
  </xs:simpleType>

  <!-- NUL terminated strings -->

  <!--
  EXERCISE

  Define a reusable simple type named zString which is delimited and the
  terminator is the NUL character (ASCII 0).

  You will need to use a DFDL character entity to represent NUL.

  You will need to add a dfdl:alignment property of 8 (bits) since these
  strings must be 8-bit aligned.
  -->
  <xs:simpleType name="zString"
                 ... properties here .... >
    <xs:restriction base="xs:string"/>
  </xs:simpleType>

  <xs:group name="discriminateTrue">
    <xs:sequence>
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:discriminator test="{ fn:true() }"/>
        </xs:appinfo>
      </xs:annotation>
    </xs:sequence>
  </xs:group>

  <xs:element name="file">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="record" maxOccurs="unbounded" dfdl:occursCountKind="implicit">
          <xs:complexType>
            <xs:sequence>
              <!--
              EXERCISE

              Insert 4 elements here which are the presence indicator bits.
              Corresponding to each element of data, the PI field should be named
              with "PI" suffix e.g., lastNamePI.

              Give each element the PI type defined above. Don't forget you need
              a tns: prefix to refer to the global simple type definition.
              -->
              <xs:element ... />
              <xs:group ref="tns:discriminateTrue"/>
              <xs:element ... />
              <xs:element ... />
              <xs:element ... />
              <!--
              EXERCISE

              Now add the first 3 data carrying
              elements lastName, firstName, and middleNamec.
              Make them optional via minOccurs="0".
              Note that minOccurs is NOT a dfdl: property. It is an
              XML schema attribute of element declarations, so has no prefix
              on its name.

              These 3 elements each have the zString type defined above.

              Note that the dfdl:occursCountKind above is "expression",
              Provide a dfdl:occursCount expression for each that uses
              the value of the presence indicator defined above.

              E.g., for lastName, you will want the value of the
              ../lastNamePI element.
              -->
              <xs:element ... />
              <xs:element ... />
              <xs:element ... />
              <!--
              EXERCISE

              For the DOB element, it has type xs:date, and minOccurs="0",
              but several new properties are also added because the
              representation of this wants to be 'bcd' a kind of packed
              decimal data representation.

              Study the properties here. Note that the calendar pattern
              is different.
              -->
              <xs:element name="DOB" type="xs:date" minOccurs="0"
                          dfdl:occursCount='{ ../DOBPI }'
                          dfdl:calendarPattern="MMddyyyy"
                          dfdl:calendarPatternKind="explicit"
                          dfdl:binaryCalendarRep="bcd"
                          dfdl:lengthKind="explicit"
                          dfdl:lengthUnits="bytes"
                          dfdl:length="4"
                          dfdl:alignment="8"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
</xs:schema>
